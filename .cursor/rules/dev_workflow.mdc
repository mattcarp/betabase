---
description: Development workflow using ByteRover for knowledge persistence and long-running agent patterns
globs: **/*
alwaysApply: true
---

# Development Workflow (ByteRover + Long-Running Agent)

This guide outlines the development workflow using ByteRover for knowledge management and the long-running agent harness for multi-session work.

## Primary Tools

### 1. ByteRover MCP (Knowledge Persistence)
ByteRover stores and retrieves knowledge across sessions:
- **Store**: Patterns, solutions, gotchas learned during development
- **Retrieve**: Context before starting new work

### 2. Long-Running Agent Harness (Session Management)
File-based tracking for multi-context window work:
- `claude-progress.txt`: Session-by-session log
- `features.json`: Feature specifications and status
- `HANDOFF-*.md`: Complex work handoffs

---

## Standard Development Process

### Starting a New Feature

1. **Gather Context**
   ```
   byterover-retrieve-knowledge: "patterns for [feature area]"
   ```

2. **Check Progress**
   - Read `claude-progress.txt` last 2-3 entries
   - Read `features.json` for current priorities

3. **Run Smoke Test**
   - Verify app loads before making changes
   - Fix any existing issues first

4. **Work on ONE Feature**
   - Select highest-priority `passes: false` feature
   - Implement incrementally
   - Test each change

5. **Complete the Session**
   - Verify changes work E2E
   - Commit with descriptive message
   - Update `claude-progress.txt`
   - Store knowledge in ByteRover

---

## Feature Lifecycle

```
[Feature Identified]
     ↓
[Added to features.json with passes: false]
     ↓
[Selected for work (highest priority)]
     ↓
[Implementation]
     ↓
[E2E Testing/Verification]
     ↓
[Mark passes: true in features.json]
     ↓
[Commit + Update claude-progress.txt]
     ↓
[Store patterns in ByteRover]
```

---

## ByteRover Usage Patterns

### When to RETRIEVE Knowledge
- Starting any new task
- Before making architectural decisions
- When debugging unfamiliar issues
- Working in unfamiliar codebase areas

```
byterover-retrieve-knowledge: "how does [component/feature] work"
byterover-retrieve-knowledge: "previous solutions for [error type]"
byterover-retrieve-knowledge: "patterns for [technology/approach]"
```

### When to STORE Knowledge
- Learning new patterns or APIs
- Finding error solutions
- Discovering reusable code patterns
- Completing significant implementations

```
byterover-store-knowledge: "Learned that [specific pattern/solution]
- Context: [what problem it solves]
- Implementation: [key code/approach]
- Gotchas: [things to watch out for]"
```

---

## Git Workflow

### Commit Convention
```
type(scope): Short description

- Bullet point of specific change
- Another change
- Files: list key files

Refs: F003, B001 (if applicable)
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `refactor`: Code refactor
- `test`: Tests
- `chore`: Maintenance

### When User Says "Good Job"
Suggest a commit using the `acm` alias:
```bash
git acm 'feat(area): What was accomplished'
```

Then suggest push:
```bash
git push origin $(git branch --show-current)
```

---

## Task Selection Algorithm

1. Check `features.json` for `passes: false` features
2. Sort by `priority` (lower number = higher priority)
3. Check for dependencies
4. Select the first unblocked feature
5. If all features pass, check `backlog` section
6. If nothing to do, ask user for direction

---

## Incremental Work Pattern

### ✅ Correct Approach
```
Session 1: Implement feature scaffolding
           → Commit → Update progress

Session 2: Add core logic
           → Commit → Update progress

Session 3: Add edge cases + tests
           → Commit → Mark feature complete
```

### ❌ Anti-Pattern
```
Session 1: Try to implement everything
           → Run out of context
           → Leave half-broken code
           → No progress update
           → Next session has no idea what happened
```

---

## File Reference Quick Guide

| Need To | File | Action |
|---------|------|--------|
| See what was done recently | `claude-progress.txt` | Read last 3 entries |
| Find next task | `features.json` | Find highest-priority `passes: false` |
| Understand complex WIP | `HANDOFF-*.md` | Read most recent |
| Get stored patterns | ByteRover | `retrieve-knowledge` |
| Save new patterns | ByteRover | `store-knowledge` |

---

## Integration with Existing Tools

### Playwright (E2E Testing)
- Attach `data-test-id` to new HTML elements
- Run Playwright tests before marking features complete
- Prefer E2E tests over unit tests

### Browser MCP
- Use for visual verification of features
- Take snapshots to verify UI changes
- Check console for errors

### Supabase MCP
- Query database state during debugging
- Verify data was correctly persisted
- Check for data integrity issues

---

## Debugging Workflow

1. **Check ByteRover First**
   ```
   byterover-retrieve-knowledge: "solutions for [error message]"
   ```

2. **Check Progress File**
   - Has this been encountered before?
   - What was tried previously?

3. **Document As You Go**
   - Log what you try
   - Log what doesn't work
   - This prevents repeating failed approaches

4. **Store Solution**
   ```
   byterover-store-knowledge: "Fixed [error] by [solution]"
   ```

---

## Session Boundaries

### Signs You Should End a Session
- Feature is complete and verified
- You've been working for extended period
- You're blocked and need user input
- Context is getting full (compaction happening)

### Before Ending
1. Commit all changes
2. Update `claude-progress.txt`
3. Store knowledge in ByteRover
4. Create handoff if needed

---

*This workflow uses file-based tracking + ByteRover for knowledge persistence, optimized for Cursor's long-running agent pattern.*
