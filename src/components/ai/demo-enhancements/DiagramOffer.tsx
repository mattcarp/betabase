"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { cn } from "../../../lib/utils";
import { Button } from "../../ui/button";
import { Badge } from "../../ui/badge";
import {
  GitBranch,
  Workflow,
  Network,
  Loader2,
  X,
  Maximize2,
  Download,
  ZoomIn,
  ZoomOut,
  ChevronUp,
  Presentation,
  Check,
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";

type DiagramType = "workflow" | "explainer";

interface DiagramOfferProps {
  responseContent: string;
  onAccept?: () => void;
  onDismiss?: () => void;
  className?: string;
  autoGenerateDelay?: number; // ms to wait before starting background generation
}

interface CachedDiagram {
  status: "generating" | "ready" | "error";
  imageBase64?: string;
  imageMimeType?: string;
  error?: string;
}

interface DiagramCache {
  explainer: CachedDiagram | null;
  workflow: CachedDiagram | null;
}

/**
 * DiagramOffer - Non-blocking Nano Banana Pro diagram generation with BACKGROUND CACHING
 *
 * Workflow:
 * 1. After response completes, START generating BOTH diagram types in background
 * 2. Show offer buttons to user (diagrams generating silently)
 * 3. User clicks Explainer or Workflow button
 * 4. If cached: show INSTANTLY. If still generating: show progress
 * 5. If user sends new message before viewing, discard cached diagrams
 */
export function DiagramOffer({
  responseContent,
  onAccept,
  onDismiss,
  className,
  autoGenerateDelay = 800, // Start background generation quickly
}: DiagramOfferProps) {
  const [isVisible, setIsVisible] = useState(false);
  const [cache, setCache] = useState<DiagramCache>({ explainer: null, workflow: null });
  const [showDiagram, setShowDiagram] = useState(false);
  const [selectedType, setSelectedType] = useState<DiagramType>("explainer");
  const [zoom, setZoom] = useState(1);
  const abortControllersRef = useRef<{ explainer: AbortController | null; workflow: AbortController | null }>({
    explainer: null,
    workflow: null,
  });
  const contentHashRef = useRef<string>("");

  // Generate a hash of content to detect changes
  const getContentHash = (content: string) => content.substring(0, 100) + content.length;

  // Background generation for a specific diagram type
  const generateInBackground = useCallback(async (type: DiagramType, content: string) => {
    // Create abort controller for this generation
    const controller = new AbortController();
    abortControllersRef.current[type] = controller;

    // Mark as generating
    setCache(prev => ({
      ...prev,
      [type]: { status: "generating" as const }
    }));

    try {
      const response = await fetch("/api/diagram", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: `Create a ${type} diagram based on this content`,
          context: content.substring(0, 2000),
          type,
        }),
        signal: controller.signal,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Failed to generate diagram");
      }

      const result = await response.json();

      if (result.success && result.image) {
        setCache(prev => ({
          ...prev,
          [type]: {
            status: "ready" as const,
            imageBase64: result.image.base64,
            imageMimeType: result.image.mimeType,
          }
        }));
        console.log(`[Nano Banana Pro] ${type} diagram cached and ready`);
      } else {
        throw new Error("No image in response");
      }
    } catch (error: any) {
      if (error.name === "AbortError") {
        console.log(`[Nano Banana Pro] ${type} diagram generation cancelled`);
        // Don't update cache on abort - it's being discarded
      } else {
        console.error(`[Nano Banana Pro] ${type} diagram failed:`, error);
        setCache(prev => ({
          ...prev,
          [type]: {
            status: "error" as const,
            error: error.message || "Unknown error",
          }
        }));
      }
    }
  }, []);

  // Start background generation after delay
  useEffect(() => {
    if (responseContent.length < 50) return; // Don't offer for very short responses

    const currentHash = getContentHash(responseContent);

    // If content changed, abort any pending generations and reset cache
    if (contentHashRef.current !== currentHash) {
      if (abortControllersRef.current.explainer) {
        abortControllersRef.current.explainer.abort();
      }
      if (abortControllersRef.current.workflow) {
        abortControllersRef.current.workflow.abort();
      }
      setCache({ explainer: null, workflow: null });
      setShowDiagram(false);
      contentHashRef.current = currentHash;
    }

    // Start background generation after delay
    const generateTimer = setTimeout(() => {
      setIsVisible(true);
      // Start generating BOTH types in background
      generateInBackground("explainer", responseContent);
      generateInBackground("workflow", responseContent);
    }, autoGenerateDelay);

    return () => {
      clearTimeout(generateTimer);
    };
  }, [responseContent, autoGenerateDelay, generateInBackground]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllersRef.current.explainer) {
        abortControllersRef.current.explainer.abort();
      }
      if (abortControllersRef.current.workflow) {
        abortControllersRef.current.workflow.abort();
      }
    };
  }, []);

  // Show cached diagram or trigger generation
  const showCachedDiagram = useCallback((type: DiagramType) => {
    setSelectedType(type);
    setShowDiagram(true);

    // If already ready, notify parent
    if (cache[type]?.status === "ready") {
      onAccept?.();
    }
  }, [cache, onAccept]);

  // Download the diagram
  const downloadDiagram = useCallback(() => {
    const currentDiagram = cache[selectedType];
    if (currentDiagram?.imageBase64 && currentDiagram?.imageMimeType) {
      const link = document.createElement("a");
      link.href = `data:${currentDiagram.imageMimeType};base64,${currentDiagram.imageBase64}`;
      link.download = `nano-banana-${selectedType}-${Date.now()}.png`;
      link.click();
    }
  }, [cache, selectedType]);

  // Handle dismiss - abort background generations
  const handleDismiss = () => {
    setIsVisible(false);
    if (abortControllersRef.current.explainer) {
      abortControllersRef.current.explainer.abort();
    }
    if (abortControllersRef.current.workflow) {
      abortControllersRef.current.workflow.abort();
    }
    setCache({ explainer: null, workflow: null });
    onDismiss?.();
  };

  // Zoom controls
  const zoomIn = () => setZoom((z) => Math.min(z + 0.25, 3));
  const zoomOut = () => setZoom((z) => Math.max(z - 0.25, 0.5));

  const typeConfig = {
    workflow: {
      icon: Workflow,
      label: "Workflow",
      color: "text-blue-400",
      bgColor: "bg-blue-500/10",
      borderColor: "border-blue-500/30",
      hoverBg: "hover:bg-blue-500/20",
    },
    explainer: {
      icon: Presentation,
      label: "Explainer",
      color: "text-amber-400",
      bgColor: "bg-amber-500/10",
      borderColor: "border-amber-500/30",
      hoverBg: "hover:bg-amber-500/20",
    },
  };

  // Get current diagram from cache
  const currentDiagram = cache[selectedType];
  const config = typeConfig[selectedType];
  const Icon = config.icon;

  // Helper to check if a diagram type is ready
  const isTypeReady = (type: DiagramType) => cache[type]?.status === "ready";
  const isTypeGenerating = (type: DiagramType) => cache[type]?.status === "generating";

  if (!isVisible && !showDiagram) return null;

  return (
    <AnimatePresence>
      {/* Offer Buttons - shows while diagrams generate in background */}
      {isVisible && !showDiagram && (
        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          className={cn(
            "flex flex-col gap-3 mt-4 p-4",
            "bg-zinc-900/50 border border-zinc-700/50 rounded-lg",
            "backdrop-blur-sm",
            className
          )}
        >
          <p className="text-sm text-zinc-400">
            Would you like to see a diagram?
          </p>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => showCachedDiagram("explainer")}
              className={cn(
                "gap-2 transition-all duration-200",
                typeConfig.explainer.bgColor,
                typeConfig.explainer.borderColor,
                typeConfig.explainer.hoverBg
              )}
            >
              {isTypeReady("explainer") ? (
                <Check className={cn("h-4 w-4", typeConfig.explainer.color)} />
              ) : isTypeGenerating("explainer") ? (
                <Loader2 className={cn("h-4 w-4 animate-spin", typeConfig.explainer.color)} />
              ) : (
                <Presentation className={cn("h-4 w-4", typeConfig.explainer.color)} />
              )}
              <span className={typeConfig.explainer.color}>Explainer</span>
            </Button>

            <Button
              variant="outline"
              size="sm"
              onClick={() => showCachedDiagram("workflow")}
              className={cn(
                "gap-2 transition-all duration-200",
                typeConfig.workflow.bgColor,
                typeConfig.workflow.borderColor,
                typeConfig.workflow.hoverBg
              )}
            >
              {isTypeReady("workflow") ? (
                <Check className={cn("h-4 w-4", typeConfig.workflow.color)} />
              ) : isTypeGenerating("workflow") ? (
                <Loader2 className={cn("h-4 w-4 animate-spin", typeConfig.workflow.color)} />
              ) : (
                <Workflow className={cn("h-4 w-4", typeConfig.workflow.color)} />
              )}
              <span className={typeConfig.workflow.color}>Workflow</span>
            </Button>

            <Button
              variant="ghost"
              size="sm"
              onClick={handleDismiss}
              className="ml-auto h-8 w-8 p-0 text-zinc-500 hover:text-zinc-300"
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
          <p className="text-xs text-zinc-500">
            Powered by Nano Banana Pro
          </p>
        </motion.div>
      )}

      {/* Diagram Display - shows cached or generating diagram */}
      {showDiagram && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: "auto" }}
          exit={{ opacity: 0, height: 0 }}
          className={cn(
            "mt-4 rounded-lg overflow-hidden",
            "border border-purple-500/30 bg-[#1e1e2e]",
            className
          )}
        >
          {/* Header with controls */}
          <div className="flex items-center justify-between p-3 border-b border-purple-500/20 bg-zinc-900/50">
            <div className="flex items-center gap-2">
              <Icon className={cn("h-4 w-4", config.color)} />
              <span className="text-sm text-zinc-300">Nano Banana Pro</span>
              <Badge
                variant="outline"
                className={cn("text-[10px]", config.bgColor, config.borderColor, config.color)}
              >
                {config.label}
              </Badge>
              {currentDiagram?.status === "generating" && (
                <Badge variant="outline" className="text-[10px] bg-purple-500/10 border-purple-500/30 text-purple-400">
                  Generating...
                </Badge>
              )}
              {currentDiagram?.status === "ready" && (
                <Badge variant="outline" className="text-[10px] bg-green-500/10 border-green-500/30 text-green-400">
                  Ready
                </Badge>
              )}
            </div>
            <div className="flex items-center gap-1">
              {currentDiagram?.status === "ready" && (
                <>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={zoomOut}
                    className="h-7 w-7 p-0 text-zinc-500 hover:text-zinc-300"
                  >
                    <ZoomOut className="h-3.5 w-3.5" />
                  </Button>
                  <span className="text-xs text-zinc-500 min-w-[2.5rem] text-center">
                    {Math.round(zoom * 100)}%
                  </span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={zoomIn}
                    className="h-7 w-7 p-0 text-zinc-500 hover:text-zinc-300"
                  >
                    <ZoomIn className="h-3.5 w-3.5" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={downloadDiagram}
                    className="h-7 w-7 p-0 text-zinc-500 hover:text-zinc-300"
                    title="Download"
                  >
                    <Download className="h-3.5 w-3.5" />
                  </Button>
                </>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowDiagram(false)}
                className="h-7 w-7 p-0 text-zinc-500 hover:text-zinc-300"
              >
                <ChevronUp className="h-3.5 w-3.5" />
              </Button>
            </div>
          </div>

          {/* Diagram content */}
          <div className="p-4 min-h-[250px] flex items-center justify-center">
            {currentDiagram?.status === "generating" && (
              <div className="flex flex-col items-center gap-3">
                <Loader2 className="h-8 w-8 animate-spin text-purple-400" />
                <p className="text-sm text-zinc-400">
                  Creating Excalidraw-style diagram...
                </p>
              </div>
            )}

            {currentDiagram?.status === "error" && (
              <div className="flex flex-col items-center gap-3 text-red-400">
                <p className="text-sm">Failed to generate diagram</p>
                <p className="text-xs text-zinc-500">{currentDiagram.error}</p>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => generateInBackground(selectedType, responseContent)}
                  className="bg-zinc-800 border-zinc-700"
                >
                  Try Again
                </Button>
              </div>
            )}

            {currentDiagram?.status === "ready" && currentDiagram.imageBase64 && (
              <div
                className="overflow-auto max-w-full max-h-[500px] cursor-grab active:cursor-grabbing"
                style={{ transform: `scale(${zoom})`, transformOrigin: "center" }}
              >
                <img
                  src={`data:${currentDiagram.imageMimeType};base64,${currentDiagram.imageBase64}`}
                  alt={`${selectedType} diagram`}
                  className="max-w-full h-auto rounded"
                />
              </div>
            )}
          </div>
        </motion.div>
      )}

      {/* Collapsed indicator - shows when diagram is hidden but ready */}
      {!showDiagram && currentDiagram?.status === "ready" && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="mt-4"
        >
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowDiagram(true)}
            className={cn(
              "gap-2 transition-all duration-200",
              "bg-purple-500/10 border-purple-500/30 hover:bg-purple-500/20"
            )}
          >
            <Icon className={cn("h-4 w-4", config.color)} />
            <span className="text-purple-400">Show Diagram</span>
          </Button>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

/**
 * Hook for managing diagram offer state across the chat
 */
export function useDiagramOffer() {
  const [shouldOffer, setShouldOffer] = useState(false);
  const [lastResponseId, setLastResponseId] = useState<string | null>(null);

  const offerDiagram = useCallback((responseId: string) => {
    setLastResponseId(responseId);
    setShouldOffer(true);
  }, []);

  const dismissOffer = useCallback(() => {
    setShouldOffer(false);
  }, []);

  const cancelOffer = useCallback(() => {
    setShouldOffer(false);
    setLastResponseId(null);
  }, []);

  return {
    shouldOffer,
    lastResponseId,
    offerDiagram,
    dismissOffer,
    cancelOffer,
  };
}

export default DiagramOffer;
